# System Prompt 注入机制

## 概述

本文档定义了 SOUL.md、USER.md、MEMORY.md 文件内容 **如何被读取、处理、注入到 LLM 的 system prompt 中**。

> **本机制替换现有的 prompt 拼接逻辑**（`ChatboxInputBox.jsx` 中基于 `isDefaultPersonality` 和 `memoryEnabled` 的 4 个分支）。

核心原则：**全文本注入，无向量搜索，每轮对话重新读取。**

## 读取时机

### 每轮对话都重新读取

```
用户发送消息
    ↓
始终从磁盘读取 SOUL.md
    ↓
检查当前会话的记忆开关状态
    ↓ (记忆 ON)                    ↓ (记忆 OFF)
从磁盘读取 USER.md, MEMORY.md     跳过 USER.md, MEMORY.md
    ↓                              ↓
拼接 system prompt                 拼接 system prompt（仅含 SOUL.md）
    ↓                              ↓
发送给 LLM API（注册 read/write/edit 工具）  发送给 LLM API（不注册记忆相关工具）
    ↓
LLM 回复（可能调用 write/edit 修改文件）
    ↓
用户发送下一条消息
    ↓
重新从磁盘读取（此时已包含上一轮 LLM 的修改）
    ↓
...
```

**为什么每轮都读？** 因为 LLM 可能在上一轮通过 write/edit 修改了文件。重新读取确保 system prompt 始终反映最新内容。

**记忆开关如何影响流程？** 记忆开关是 per-conversation 的（复用现有 FaBrain 按钮）。关闭时 USER.md/MEMORY.md 既不读取也不可写入，但 SOUL.md 始终生效。

### 读取失败时

| 情况 | 处理 |
|------|------|
| 文件不存在 | 跳过该文件，不注入对应部分 |
| 文件为空 | 注入空内容标记：`（空）` |
| 文件读取出错（权限等） | 跳过并记录警告日志 |

## 截断策略

### 为什么需要截断

LLM 的 context window 有限。三个文件全文注入会消耗 token 预算：

```
假设：
  SOUL.md   ≈ 1000 字符 ≈ 500 tokens
  USER.md   ≈ 500 字符  ≈ 250 tokens
  MEMORY.md ≈ 5000 字符 ≈ 2500 tokens
  ─────────────────────────────────
  合计      ≈ 6500 字符 ≈ 3250 tokens

对于 128k context window 的模型，这完全没问题。
但 MEMORY.md 可能增长到 50000+ 字符，就需要截断了。
```

### 截断规则

每个文件独立截断：

| 参数 | 默认值 | 说明 |
|------|--------|------|
| 单文件最大字符数 | 20,000 | 超过则截断 |
| 头部保留比例 | 70% | 保留文件前 70% 内容 |
| 尾部保留比例 | 20% | 保留文件后 20% 内容 |
| 截断标记占比 | 10% | 用于放置截断提示文本 |

### 截断示例

一个 30,000 字符的 MEMORY.md：

```
[前 14,000 字符原样保留]

[...内容被截断，完整内容请使用 read 工具查看 MEMORY.md...]
（截断：保留了 14000+4000 字符，共 30000 字符）

[后 4,000 字符原样保留]
```

### 截断的优先级

当总 token 预算紧张时，不同文件有不同优先级：

| 文件 | 截断优先级 | 理由 |
|------|-----------|------|
| SOUL.md | 最后截断 | 人格定义是最核心的，截断会导致性格不一致 |
| USER.md | 第二截断 | 用户基本信息通常不大 |
| MEMORY.md | 优先截断 | 通常最大，且截断后 AI 仍可用 read 工具查看全文 |

## System Prompt 结构

最终的 system prompt 由以下部分拼接（替换现有 `ChatboxInputBox.jsx` 中 4 个分支的 prompt 构建逻辑）：

### 记忆 ON 时的完整 prompt

```
# System

（基础指令：角色定义、能力说明、可用工具列表）

# 人格

（SOUL.md 内容 — 始终注入）

请根据上述人格定义来塑造你的性格和语气。

# 用户信息

（USER.md 内容 — 仅记忆 ON 时注入）

在对话中获知新的用户信息时，使用 edit 工具更新 USER.md。

# 记忆

（MEMORY.md 内容 — 仅记忆 ON 时注入）

遇到值得记住的信息时，使用 edit 工具更新 MEMORY.md。定期整理，保持精炼。

# 工具

你可以使用以下工具：
- read：读取文件内容
- write：创建或覆盖文件
- edit：精确文本查找替换

# 对话规则

（对话格式、语言偏好、其他行为指令）
```

### 记忆 OFF 时的精简 prompt

```
# System

（基础指令：角色定义、能力说明）

# 人格

（SOUL.md 内容 — 始终注入）

请根据上述人格定义来塑造你的性格和语气。

# 对话规则

（对话格式、语言偏好、其他行为指令）
```

注意：记忆 OFF 时，**不注入** USER.md/MEMORY.md 部分，也**不注册** 针对这两个文件的 write/edit 工具。SOUL.md 的 read 工具始终可用。

### 注入顺序

1. **基础指令**（固定，代码中硬编码）
2. **SOUL.md 内容** + 人格引导指令（**始终注入**）
3. **USER.md 内容** + 更新引导指令（**仅记忆 ON**）
4. **MEMORY.md 内容** + 记忆引导指令（**仅记忆 ON**）
5. **工具定义**（记忆 ON 时完整工具集；记忆 OFF 时仅 SOUL.md 相关的 read 工具）
6. **对话规则**（固定）

每个注入块之间用 Markdown 标题分隔，确保清晰。

### 动态引导指令

每个文件注入后附加的引导指令，根据文件状态和记忆开关动态调整：

| 文件状态 | 引导指令 |
|----------|----------|
| SOUL.md 存在且有内容 | "请根据上述人格定义来塑造你的性格和语气。" |
| SOUL.md 不存在 | "你还没有人格定义。在第一次对话时，和主人一起创建 SOUL.md。" |
| 记忆 ON + USER.md 存在但几乎为空 | "你对主人还不太了解。在对话中自然地了解他们，并更新 USER.md。" |
| 记忆 ON + USER.md 存在且丰富 | "你已经了解了主人的一些信息（见上方）。继续在对话中学习。" |
| 记忆 ON + MEMORY.md 不存在 | "你还没有长期记忆。当有值得记住的事时，创建 MEMORY.md。" |
| 记忆 ON + MEMORY.md 接近上限 | "你的记忆快满了。请在本次对话中整理 MEMORY.md，移除过时内容。" |
| 记忆 OFF | 不注入 USER.md/MEMORY.md 相关的引导指令 |

## 性能考虑

| 关注点 | 方案 |
|--------|------|
| 文件读取延迟 | 本地文件读取通常 <1ms，可忽略 |
| token 消耗 | 三个文件合计通常 <5000 tokens，对 128k 窗口影响很小 |
| 频繁写入 | LLM 每轮最多写几次文件，对磁盘无压力 |
| 大文件截断 | 按固定规则截断，O(1) 时间复杂度 |

## 不使用向量搜索的理由

| 对比 | 全文注入（当前方案） | 向量搜索 |
|------|-------------------|----------|
| 复杂度 | 极低 | 高（需要 embedding + 向量库） |
| 依赖 | 零 | 需要 embedding API 或本地模型 |
| 准确性 | 100%（全部内容可见） | 可能遗漏相关上下文 |
| 成本 | 多消耗约 3000 tokens/轮 | embedding 调用成本 |
| 适用范围 | 文件 <50k 字符时完美 | 大量记忆时更优 |

**结论**：对于桌面宠物的使用场景，三个文件的总量很难超过 50k 字符。全文注入是最合适的方案。
